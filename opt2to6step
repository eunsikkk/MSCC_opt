% =========================================================================
% COMSOL-MATLAB: Unified Optimization (CCCV, MSCC-2/3/4/5/6 step)
%  - 안전여유(safety_eps), 평가횟수(N_EVALS) 공통 조절
%  - 모든 MSCC는 내부 6개 파라미터(first..sixth)를 항상 세팅
%  - Step별 매핑:
%    · 2step:  [first=second]=C12, [third=fourth=fifth=sixth]=C3456
%    · 3step:  [first=second]=C12, [third=fourth]=C34, [fifth=sixth]=C56
%    · 4step:   first=C1, second=C2, [third=fourth]=C34, [fifth=sixth]=C56
%    · 5step:   first=C1, second=C2, third=C3, fourth=C4, [fifth=sixth]=C56
%    · 6step:   first=C1, second=C2, third=C3, fourth=C4, fifth=C5, sixth=C6
%  - 로깅: [t, s(=min(liion.Ect)), cv_frac, E_Wh, Vdiff_min/max, T_avg, T_max]
%  - 시간은 't', 온도는 'T_*' 표기, t80 없음
% =========================================================================
clc; clear; close all;
import com.comsol.model.*
import com.comsol.model.util.*

%% 0) 공통 파라미터 ----------------------------------------------------------
safety_eps = 0;   % [V]  min(liion.Ect) > safety_eps 이어야 안전
N_EVALS    = 500;    % surrogateopt MaxFunctionEvaluations (모든 프로토콜 공통)

%% 1) 경로/출력 폴더 ---------------------------------------------------------
base_dir = 'G:\공유 드라이브\Battery Software Group (2025)\Members\최은식\COMSOL\MSCC_optimization\MSCC_CCCV_opt';
assert(isfolder(base_dir), '기본 폴더가 없습니다: %s', base_dir);
ts = datestr(now,'yyyymmdd_HHMMSS');
out_dir = fullfile(base_dir, ['run_' ts]);
if ~isfolder(out_dir), mkdir(out_dir); end

fn_cccv  = fullfile(out_dir, ['cccv_optimization_log_'  ts '.csv']);
fn_mscc2 = fullfile(out_dir, ['mscc2_optimization_log_' ts '.csv']);
fn_mscc3 = fullfile(out_dir, ['mscc3_optimization_log_' ts '.csv']);
fn_mscc4 = fullfile(out_dir, ['mscc4_optimization_log_' ts '.csv']);
fn_mscc5 = fullfile(out_dir, ['mscc5_optimization_log_' ts '.csv']);
fn_mscc6 = fullfile(out_dir, ['mscc6_optimization_log_' ts '.csv']);

%% 2) 모델 로드 --------------------------------------------------------------
filepath = 'C:\Users\user\Downloads';
filename = 'ES_MSCC_PC_1116.mph';   % std1/dset1, std2/dset3 포함 모델
full_path = fullfile(filepath, filename);
assert(isfile(full_path),'mph 파일 없음: %s', full_path);

model = mphload(full_path);
ModelUtil.showProgress(true);
disp('모델 불러오기 완료.');

%% 3) CSV 헤더 생성 ----------------------------------------------------------
% CCCV: [C, t, s, cv_frac, E_Wh, Vdiff_min, Vdiff_max, T_avg, T_max]
init_csv(fn_cccv,  {'C','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

% MSCC2: [C12 C3456, t, s, cv_frac, E_Wh, Vdiff_min, Vdiff_max, T_avg, T_max]
init_csv(fn_mscc2, {'C12','C3456','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

% MSCC3: [C12 C34 C56, ...]
init_csv(fn_mscc3, {'C12','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

% MSCC4: [C1 C2 C34 C56, ...]
init_csv(fn_mscc4, {'C1','C2','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

% MSCC5: [C1 C2 C3 C4 C56, ...]
init_csv(fn_mscc5, {'C1','C2','C3','C4','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

% MSCC6: [C1 C2 C3 C4 C5 C6, ...]
init_csv(fn_mscc6, {'C1','C2','C3','C4','C5','C6','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});

%% 4) 최적화: CCCV ----------------------------------------------------------
disp('===== CCCV 최적화를 시작합니다 =====');
lb_cccv = 0.1;  ub_cccv = 6.0;
obj_cccv = @(C) evaluate_and_log_CCCV(C, model, safety_eps, fn_cccv);

opts_cccv = optimoptions('surrogateopt', ...
    'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_rate, cccv_min_t, exitflag_cccv, output_cccv, trials_cccv] = ...
    surrogateopt(obj_cccv, lb_cccv, ub_cccv, opts_cccv);

fprintf('\n--- CCCV 결과 ---\n최적 t = %.2f s, 최적 C = %.3f C\n\n', cccv_min_t, optimal_C_rate);

%% 5) 최적화: MSCC 2-step ---------------------------------------------------
% 매핑: first=second=C12, third=fourth=fifth=sixth=C3456
disp('===== MSCC (2-step) 최적화를 시작합니다 =====');
lb_mscc2 = [0.1 0.1];  ub_mscc2 = [8.0 6.0];
obj_mscc2 = @(Cx) evaluate_and_log_MSCC2(Cx, model, safety_eps, fn_mscc2);

opts_mscc2 = optimoptions('surrogateopt', 'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_mscc2, mscc2_min_t, exitflag_mscc2, output_mscc2, trials_mscc2] = ...
    surrogateopt(obj_mscc2, lb_mscc2, ub_mscc2, opts_mscc2);

fprintf('\n--- MSCC2 결과 ---\n최적 t = %.2f s, 최적 [C12 C3456] = [%.3f %.3f]\n\n', ...
    mscc2_min_t, optimal_C_mscc2);

%% 6) 최적화: MSCC 3-step ---------------------------------------------------
% 매핑: first=second=C12, third=fourth=C34, fifth=sixth=C56
disp('===== MSCC (3-step) 최적화를 시작합니다 =====');
lb_mscc3 = [0.1 0.1 0.1];  ub_mscc3 = [8.0 6.0 2.0];
obj_mscc3 = @(C) evaluate_and_log_MSCC3(C, model, safety_eps, fn_mscc3);

opts_mscc3 = optimoptions('surrogateopt', 'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_mscc3, mscc3_min_t, exitflag_mscc3, output_mscc3, trials_mscc3] = ...
    surrogateopt(obj_mscc3, lb_mscc3, ub_mscc3, opts_mscc3);

fprintf('\n--- MSCC3 결과 ---\n최적 t = %.2f s, 최적 [C12 C34 C56] = [%.3f %.3f %.3f]\n\n', ...
    mscc3_min_t, optimal_C_mscc3);

%% 7) 최적화: MSCC 4-step ---------------------------------------------------
% 매핑: first=C1, second=C2, third=fourth=C34, fifth=sixth=C56
disp('===== MSCC (4-step) 최적화를 시작합니다 =====');
lb_mscc4 = [0.1 0.1 0.1 0.1];  ub_mscc4 = [8.0 6.0 6.0 2.0];
obj_mscc4 = @(C) evaluate_and_log_MSCC4(C, model, safety_eps, fn_mscc4);

opts_mscc4 = optimoptions('surrogateopt', 'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_mscc4, mscc4_min_t, exitflag_mscc4, output_mscc4, trials_mscc4] = ...
    surrogateopt(obj_mscc4, lb_mscc4, ub_mscc4, opts_mscc4);

fprintf('\n--- MSCC4 결과 ---\n최적 t = %.2f s, 최적 [C1 C2 C34 C56] = [%.3f %.3f %.3f %.3f]\n\n', ...
    mscc4_min_t, optimal_C_mscc4);

%% 8) 최적화: MSCC 5-step ---------------------------------------------------
% 매핑: first=C1, second=C2, third=C3, fourth=C4, fifth=sixth=C56
disp('===== MSCC (5-step) 최적화를 시작합니다 =====');
lb_mscc5 = [0.1 0.1 0.1 0.1 0.1];  ub_mscc5 = [8.0 6.0 6.0 6.0 2.0];
obj_mscc5 = @(C) evaluate_and_log_MSCC5(C, model, safety_eps, fn_mscc5);

opts_mscc5 = optimoptions('surrogateopt', 'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_mscc5, mscc5_min_t, exitflag_mscc5, output_mscc5, trials_mscc5] = ...
    surrogateopt(obj_mscc5, lb_mscc5, ub_mscc5, opts_mscc5);

fprintf('\n--- MSCC5 결과 ---\n최적 t = %.2f s, 최적 [C1 C2 C3 C4 C56] = [%.3f %.3f %.3f %.3f %.3f]\n\n', ...
    mscc5_min_t, optimal_C_mscc5);

%% 9) 최적화: MSCC 6-step ---------------------------------------------------
% 매핑: first=C1, second=C2, third=C3, fourth=C4, fifth=C5, sixth=C6
disp('===== MSCC (6-step) 최적화를 시작합니다 =====');
lb_mscc6 = [0.1 0.1 0.1 0.1 0.1 0.1];  ub_mscc6 = [8.0 6.0 6.0 6.0 6.0 2.0];
obj_mscc6 = @(C) evaluate_and_log_MSCC6(C, model, safety_eps, fn_mscc6);

opts_mscc6 = optimoptions('surrogateopt', 'MaxFunctionEvaluations', N_EVALS, ...
    'Display','iter', 'PlotFcn','surrogateoptplot');

[optimal_C_mscc6, mscc6_min_t, exitflag_mscc6, output_mscc6, trials_mscc6] = ...
    surrogateopt(obj_mscc6, lb_mscc6, ub_mscc6, opts_mscc6);

fprintf('\n--- MSCC6 결과 ---\n최적 t = %.2f s, 최적 [C1..C6] = [%.3f %.3f %.3f %.3f %.3f %.3f]\n\n', ...
    mscc6_min_t, optimal_C_mscc6);

%% 10) 요약 MAT 저장 ---------------------------------------------------------
save(fullfile(out_dir, ['run_summary_' ts '.mat']), ...
    'safety_eps','N_EVALS','full_path','out_dir', ...
    'optimal_C_rate','cccv_min_t','exitflag_cccv','output_cccv','trials_cccv', ...
    'optimal_C_mscc2','mscc2_min_t','exitflag_mscc2','output_mscc2','trials_mscc2', ...
    'optimal_C_mscc3','mscc3_min_t','exitflag_mscc3','output_mscc3','trials_mscc3', ...
    'optimal_C_mscc4','mscc4_min_t','exitflag_mscc4','output_mscc4','trials_mscc4', ...
    'optimal_C_mscc5','mscc5_min_t','exitflag_mscc5','output_mscc5','trials_mscc5', ...
    'optimal_C_mscc6','mscc6_min_t','exitflag_mscc6','output_mscc6','trials_mscc6');

fprintf('CSV/MAT 저장 완료. 출력 폴더: %s\n', out_dir);

% ============================ Local Functions =============================
function init_csv(fn, names)
    if ~isfile(fn)
        T = cell2table(cell(0,numel(names)), 'VariableNames', names);
        writetable(T, fn);
    end
end

function [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = ...
    postproc_common(model, dset)
    expr = {'t','E_cell','liion.cdc1.Icell','SOC','liion.Ect', ...
            'liion.cdc1.CC_CH','liion.cdc1.CV_CH'};
    D = mpheval(model, expr, 'dataset', dset, 'edim','point', 'selection', 2, 'solnum','all');
    t = D.d1; E = D.d2; I = D.d3; v = D.d5; cc = D.d6; cv = D.d7;
    idx = (cc==1)|(cv==1);
    [T_avg, T_max] = get_T_peaks(model, dset);
    if ~any(idx)
        t_charge = 1e9; s = -inf; cv_frac = nan; E_Wh = nan;
        vmin = nan; vmax = nan; return;
    end
    tchg = t(idx); Echg = E(idx); Ichg = I(idx); vchg = v(idx); cvchg = cv(idx);
    t_charge = tchg(end);
    s        = min(vchg);
    cv_frac  = mean(cvchg==1);
    E_Wh     = trapz(tchg, Echg.*Ichg)/3600;
    vmin     = min(vchg); vmax = max(vchg);
end

function cost = evaluate_and_log_CCCV(C_rate, model, safety_eps, fn_csv)
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    fprintf('[CCCV  F%04d] C=%.6g (%s)\n', fcnt, C_rate, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('C_rate', num2str(C_rate));
        model.study('std1').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset1');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C_rate, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('CCCV 실패: %s', ME.message);
        T = table(C_rate, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- MSCC 2-step: [C12, C3456] -------------------------------------
function cost = evaluate_and_log_MSCC2(Cx, model, safety_eps, fn_csv)
    % 매핑: first=second=C12, third=fourth=fifth=sixth=C3456
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    C12=Cx(1); C3456=Cx(2);
    fprintf('[MSCC2 F%04d] C12=%.6g, C3456=%.6g (%s)\n', fcnt, C12, C3456, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('first_MSCC_Crate',  num2str(C12));
        model.param.set('second_MSCC_Crate', num2str(C12));
        model.param.set('third_MSCC_Crate',  num2str(C3456));
        model.param.set('fourth_MSCC_Crate', num2str(C3456));
        model.param.set('fifth_MSCC_Crate',  num2str(C3456));
        model.param.set('sixth_MSCC_Crate',  num2str(C3456));
        model.study('std2').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset3');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C12, C3456, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C12','C3456','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('MSCC2 실패: %s', ME.message);
        T = table(C12, C3456, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C12','C3456','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- MSCC 3-step: [C12, C34, C56] ----------------------------------
function cost = evaluate_and_log_MSCC3(C, model, safety_eps, fn_csv)
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    C12=C(1); C34=C(2); C56=C(3);
    fprintf('[MSCC3 F%04d] C12=%.6g, C34=%.6g, C56=%.6g (%s)\n', fcnt, C12, C34, C56, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('first_MSCC_Crate',  num2str(C12));
        model.param.set('second_MSCC_Crate', num2str(C12));
        model.param.set('third_MSCC_Crate',  num2str(C34));
        model.param.set('fourth_MSCC_Crate', num2str(C34));
        model.param.set('fifth_MSCC_Crate',  num2str(C56));
        model.param.set('sixth_MSCC_Crate',  num2str(C56));
        model.study('std2').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset3');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C12, C34, C56, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C12','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('MSCC3 실패: %s', ME.message);
        T = table(C12, C34, C56, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C12','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- MSCC 4-step: [C1, C2, C34, C56] --------------------------------
function cost = evaluate_and_log_MSCC4(C, model, safety_eps, fn_csv)
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    C1=C(1); C2=C(2); C34=C(3); C56=C(4);
    fprintf('[MSCC4 F%04d] C1=%.6g, C2=%.6g, C34=%.6g, C56=%.6g (%s)\n', fcnt, C1, C2, C34, C56, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('first_MSCC_Crate',  num2str(C1));
        model.param.set('second_MSCC_Crate', num2str(C2));
        model.param.set('third_MSCC_Crate',  num2str(C34));
        model.param.set('fourth_MSCC_Crate', num2str(C34));
        model.param.set('fifth_MSCC_Crate',  num2str(C56));
        model.param.set('sixth_MSCC_Crate',  num2str(C56));
        model.study('std2').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset3');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C1, C2, C34, C56, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C1','C2','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('MSCC4 실패: %s', ME.message);
        T = table(C1, C2, C34, C56, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C1','C2','C34','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- MSCC 5-step: [C1, C2, C3, C4, C56] -----------------------------
function cost = evaluate_and_log_MSCC5(C, model, safety_eps, fn_csv)
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    C1=C(1); C2=C(2); C3=C(3); C4=C(4); C56=C(5);
    fprintf('[MSCC5 F%04d] C1=%.6g, C2=%.6g, C3=%.6g, C4=%.6g, C56=%.6g (%s)\n', ...
        fcnt, C1, C2, C3, C4, C56, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('first_MSCC_Crate',  num2str(C1));
        model.param.set('second_MSCC_Crate', num2str(C2));
        model.param.set('third_MSCC_Crate',  num2str(C3));
        model.param.set('fourth_MSCC_Crate', num2str(C4));
        model.param.set('fifth_MSCC_Crate',  num2str(C56));
        model.param.set('sixth_MSCC_Crate',  num2str(C56));
        model.study('std2').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset3');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C1, C2, C3, C4, C56, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C1','C2','C3','C4','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('MSCC5 실패: %s', ME.message);
        T = table(C1, C2, C3, C4, C56, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C1','C2','C3','C4','C56','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- MSCC 6-step: [C1..C6] -----------------------------------------
function cost = evaluate_and_log_MSCC6(C, model, safety_eps, fn_csv)
    persistent fcnt; if isempty(fcnt), fcnt=0; end; fcnt=fcnt+1;
    C1=C(1); C2=C(2); C3=C(3); C4=C(4); C5=C(5); C6=C(6);
    fprintf('[MSCC6 F%04d] [%.6g %.6g %.6g %.6g %.6g %.6g] (%s)\n', ...
        fcnt, C1, C2, C3, C4, C5, C6, datestr(now,'HH:MM:SS.FFF'));
    PEN = 1e9;
    try
        model.param.set('first_MSCC_Crate',  num2str(C1));
        model.param.set('second_MSCC_Crate', num2str(C2));
        model.param.set('third_MSCC_Crate',  num2str(C3));
        model.param.set('fourth_MSCC_Crate', num2str(C4));
        model.param.set('fifth_MSCC_Crate',  num2str(C5));
        model.param.set('sixth_MSCC_Crate',  num2str(C6));
        model.study('std2').run();
        [t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max] = postproc_common(model,'dset3');
        cost = (s<=safety_eps) * (PEN + (safety_eps - s)*1e6) + (s>safety_eps) * t_charge;
        T = table(C1, C2, C3, C4, C5, C6, t_charge, s, cv_frac, E_Wh, vmin, vmax, T_avg, T_max, ...
            'VariableNames', {'C1','C2','C3','C4','C5','C6','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
    catch ME
        warning('MSCC6 실패: %s', ME.message);
        T = table(C1, C2, C3, C4, C5, C6, 1e9, -inf, nan, nan, nan, nan, nan, nan, ...
            'VariableNames', {'C1','C2','C3','C4','C5','C6','t','s','cv_frac','E_Wh','Vdiff_min','Vdiff_max','T_avg','T_max'});
        writetable(T, fn_csv, 'WriteMode','Append');
        cost = 1e9;
    end
end

% ---------- 온도 피크 취득 --------------------------------------------------
function [T_avg_peak, T_max_peak] = get_T_peaks(model, dset)
    T_avg_peak = nan; T_max_peak = nan;
    try
        G = mpheval(model,'T_avg','dataset',dset,'edim','domain','solnum','all');
        T_avg_peak = max(G.d1(:),[],'omitnan');
    catch, end
    try
        G = mpheval(model,'T_max','dataset',dset,'edim','domain','solnum','all');
        T_max_peak = max(G.d1(:),[],'omitnan');
    catch, end
end
