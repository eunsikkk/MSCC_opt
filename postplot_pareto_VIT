% =========================================================================
% Pareto 3D (t, s, T_avg) for: CCCV + MSCC2 + MSCC3 + MSCC4 + MSCC5 + MSCC6
% - run_* 폴더에서 각 로그를 읽어서 3D 파레토(최소화: t, -s, T_avg) 그림 저장
% - 그림 저장 경로: G:\...\COMSOL\Figure\pareto_YYYYMMDD_HHMMSS\pareto3D_*.png
% - 토글: 최신 run_* 자동 선택 vs 대화형 선택 (use_latest)
% =========================================================================
clc; clear; close all;

%% 0) 입력/출력 경로 --------------------------------------------------------
base_dir = 'G:\공유 드라이브\Battery Software Group (2025)\Members\최은식\COMSOL\MSCC_optimization\MSCC_CCCV_opt';
assert(isfolder(base_dir), '기본 폴더 없음: %s', base_dir);

% === 토글 스위치: true면 최신 run_* 자동선택, false면 대화형 선택 ===
use_latest = false;

% Figure 저장 루트
fig_base_dir = 'G:\공유 드라이브\Battery Software Group (2025)\Members\최은식\COMSOL\Figure';
assert(isfolder(fileparts(fig_base_dir)) || isfolder(fig_base_dir), 'Figure 상위 폴더가 유효하지 않습니다.');
ts = datestr(now,'yyyymmdd_HHMMSS');
fig_out_dir = fullfile(fig_base_dir, ['pareto_' ts]);
if ~isfolder(fig_out_dir), mkdir(fig_out_dir); end

%% 1) run_* 폴더 선택 -------------------------------------------------------
if use_latest
    d = dir(fullfile(base_dir, 'run_*'));
    assert(~isempty(d), 'run_* 폴더가 없습니다. 먼저 최적화 스크립트를 실행하세요.');
    [~,ix] = max([d.datenum]);
    run_dir = fullfile(base_dir, d(ix).name);
else
    run_dir = uigetdir(base_dir, '분석할 run_* 폴더를 선택하세요');
    if isstring(run_dir), run_dir = char(run_dir); end
    assert(~isequal(run_dir,0), '폴더 선택이 취소되었습니다.');
    [~,selname] = fileparts(run_dir);
    assert(startsWith(selname,'run_'), '선택한 폴더명이 run_* 형식이 아닙니다: %s', selname);
end

fprintf('Using run dir: %s\n', run_dir);

%% 2) 로그 파일 경로 지정 (6종류 모두) --------------------------------------
cccv_log  = pick_one_file(run_dir, 'cccv_optimization_log_*.csv');
mscc2_log = pick_one_file(run_dir, 'mscc2_optimization_log_*.csv');
mscc3_log = pick_one_file(run_dir, 'mscc3_optimization_log_*.csv');
mscc4_log = pick_one_file(run_dir, 'mscc4_optimization_log_*.csv');
mscc5_log = pick_one_file(run_dir, 'mscc5_optimization_log_*.csv');
mscc6_log = pick_one_file(run_dir, 'mscc6_optimization_log_*.csv');

fprintf('  CCCV  log: %s\n',  cccv_log);
fprintf('  MSCC2 log: %s\n', mscc2_log);
fprintf('  MSCC3 log: %s\n', mscc3_log);
fprintf('  MSCC4 log: %s\n', mscc4_log);
fprintf('  MSCC5 log: %s\n', mscc5_log);
fprintf('  MSCC6 log: %s\n', mscc6_log);

%% 3) 데이터 로드 & 컬럼 체크 ----------------------------------------------
TC  = readtable(cccv_log);
TM2 = readtable(mscc2_log);
TM3 = readtable(mscc3_log);
TM4 = readtable(mscc4_log);
TM5 = readtable(mscc5_log);
TM6 = readtable(mscc6_log);

needCols = {'t','s','T_avg'};
assert(all(ismember(needCols, TC.Properties.VariableNames )), 'CCCV 로그에 t/s/T_avg 컬럼이 없습니다.');
assert(all(ismember(needCols, TM2.Properties.VariableNames)), 'MSCC2 로그에 t/s/T_avg 컬럼이 없습니다.');
assert(all(ismember(needCols, TM3.Properties.VariableNames)), 'MSCC3 로그에 t/s/T_avg 컬럼이 없습니다.');
assert(all(ismember(needCols, TM4.Properties.VariableNames)), 'MSCC4 로그에 t/s/T_avg 컬럼이 없습니다.');
assert(all(ismember(needCols, TM5.Properties.VariableNames)), 'MSCC5 로그에 t/s/T_avg 컬럼이 없습니다.');
assert(all(ismember(needCols, TM6.Properties.VariableNames)), 'MSCC6 로그에 t/s/T_avg 컬럼이 없습니다.');

% 색상 팔레트 (CCCV ~ MSCC6 순서)
blue    = [0,115,194]/255;   % CCCV
purple  = [128,0,128]/255;   % MSCC2
green   = [0.20,0.60,0.20];  % MSCC3
red     = [205,83,76]/255;   % MSCC4
orange  = [0.93,0.69,0.13];  % MSCC5
gray    = [0.30,0.30,0.30];  % MSCC6

% 데이터셋 패킹
DS = struct('name',{},'t',{},'s',{},'T',{},'color',{});
DS(end+1) = struct('name','CCCV',  't',TC.t,  's',TC.s,  'T',TC.T_avg,  'color',blue);
DS(end+1) = struct('name','MSCC2', 't',TM2.t, 's',TM2.s, 'T',TM2.T_avg, 'color',purple);
DS(end+1) = struct('name','MSCC3', 't',TM3.t, 's',TM3.s, 'T',TM3.T_avg, 'color',green);
DS(end+1) = struct('name','MSCC4', 't',TM4.t, 's',TM4.s, 'T',TM4.T_avg, 'color',red);
DS(end+1) = struct('name','MSCC5', 't',TM5.t, 's',TM5.s, 'T',TM5.T_avg, 'color',orange);
DS(end+1) = struct('name','MSCC6', 't',TM6.t, 's',TM6.s, 'T',TM6.T_avg, 'color',gray);

%% 4) 3D 파레토 (t, s, T_avg) — 프로토콜별로 각각 저장 -----------------------
% 목적: 최소화 [t, -s, T_avg]  (즉, t 작게, s 크게, T_avg 작게)
for k = 1:numel(DS)
    name = DS(k).name;
    t = DS(k).t; s = DS(k).s; T = DS(k).T; c = DS(k).color;

    f = figure(2013+k); clf; hold on; grid on; view(45,25);
    set(gcf,'Color','w');

    % 전체 샘플 점
    scatter3(t, s, T, 18, c, 'filled', 'MarkerFaceAlpha',0.22, ...
        'DisplayName', [name ' 샘플']);

    % 파레토 점 (해당 프로토콜 데이터셋 내부에서만 계산)
    F = [t, -s, T];                 % 모두 "작을수록 좋은" 형태
    mask_nd = isNondominatedND(F);  % 비지배해
    scatter3(t(mask_nd), s(mask_nd), T(mask_nd), 54, c, 'o', ...
        'LineWidth',1.4, 'MarkerFaceColor','none', ...
        'DisplayName', [name ' Pareto']);

    xlabel('t (s)');
    ylabel('s (V)  ↑');
    zlabel('T_{avg} (K)');
    title(sprintf('Pareto 3D — t vs s vs T_{avg} (%s)', name));
    legend('Location','best'); set(gca,'FontSize',11);

    % 저장
    out_png = fullfile(fig_out_dir, ['pareto3D_' name '.png']);
    export_png(f, out_png);
    fprintf('Saved: %s\n', out_png);
end

%% ====================== 최적 C-rate 시뮬레이션 ============================
fprintf('\n[SIM] 최적 C-rate 시뮬레이션 (liion.Ect) 시작\n');

import com.comsol.model.*
import com.comsol.model.util.*
ModelUtil.showProgress(true);

% 5.1) 최적해 요약 MAT 로드
summary_mat = pick_one_file(run_dir, 'run_summary_*.mat');
S = load(summary_mat);

% --- 최적 C-rate ---
C_cccv  = S.optimal_C_rate;          % scalar
C_mscc2 = S.optimal_C_mscc2(:).';    % [C12 C3456]
C_mscc3 = S.optimal_C_mscc3(:).';    % [C12 C34 C56]
C_mscc4 = S.optimal_C_mscc4(:).';    % [C1 C2 C34 C56]
C_mscc5 = S.optimal_C_mscc5(:).';    % [C1 C2 C3 C4 C56]
C_mscc6 = S.optimal_C_mscc6(:).';    % [C1 C2 C3 C4 C5 C6]

% --- 각 프로토콜별 최적 충전 시간 [s] (summary 안 변수 이름에 맞게 조정 필요) ---
t_cccv  = S.cccv_min_t;
t_mscc2 = S.mscc2_min_t;
t_mscc3 = S.mscc3_min_t;
t_mscc4 = S.mscc4_min_t;
t_mscc5 = S.mscc5_min_t;
t_mscc6 = S.mscc6_min_t;

% 5.2) 모델 로드
filepath = 'C:\Users\user\Downloads';
filename = 'ES_MSCC_PC_1116.mph';
full_path = fullfile(filepath, filename);
assert(isfile(full_path),'mph 파일 없음: %s', full_path);
model = mphload(full_path);

% 5.4) 실행 (프로토콜당 1회 실행, tlist = range(0,10,t_cycling))
% 5.4) 실행 (프로토콜당 1회 실행, tlist = range(0,10,t_cycling))

fprintf('\n[SIM] Running CCCV...\n');
R_cccv  = run_and_eval('CCCV',  model, C_cccv,  t_cccv);

fprintf('\n[SIM] Running MSCC2...\n');
R_mscc2 = run_and_eval('MSCC2', model, C_mscc2, t_mscc2);

fprintf('\n[SIM] Running MSCC3...\n');
R_mscc3 = run_and_eval('MSCC3', model, C_mscc3, t_mscc3);

fprintf('\n[SIM] Running MSCC4...\n');
R_mscc4 = run_and_eval('MSCC4', model, C_mscc4, t_mscc4);

fprintf('\n[SIM] Running MSCC5...\n');
R_mscc5 = run_and_eval('MSCC5', model, C_mscc5, t_mscc5);

fprintf('\n[SIM] Running MSCC6...\n');
R_mscc6 = run_and_eval('MSCC6', model, C_mscc6, t_mscc6);

%% 5.5) 색상 (위 파레토 팔레트와 동일)
blue    = [0,115,194]/255;   % CCCV
purple  = [128,0,128]/255;   % MSCC2
green   = [0.20,0.60,0.20];  % MSCC3
red     = [205,83,76]/255;   % MSCC4
orange  = [0.93,0.69,0.13];  % MSCC5
gray    = [0.30,0.30,0.30];  % MSCC6

%% 5.1) Figure 1 — 전압/전류 vs time (yyaxis)
f1 = figure(4101); clf; set(gcf,'Color','w'); hold on; grid on;
title('Voltage & Current vs time (Optimal C)');

yyaxis left;
plot(R_cccv.t,  R_cccv.E,  '-',  'LineWidth',1.5, 'Color',blue);
plot(R_mscc2.t, R_mscc2.E, '-',  'LineWidth',1.5, 'Color',purple);
plot(R_mscc3.t, R_mscc3.E, '-',  'LineWidth',1.5, 'Color',green);
plot(R_mscc4.t, R_mscc4.E, '-',  'LineWidth',1.5, 'Color',red);
plot(R_mscc5.t, R_mscc5.E, '-',  'LineWidth',1.5, 'Color',orange);
plot(R_mscc6.t, R_mscc6.E, '-',  'LineWidth',1.5, 'Color',gray);
ylabel('E_{cell} (V)');

yyaxis right;
plot(R_cccv.t,  R_cccv.I,  '--', 'LineWidth',1.2, 'Color',blue);
plot(R_mscc2.t, R_mscc2.I, '--', 'LineWidth',1.2, 'Color',purple);
plot(R_mscc3.t, R_mscc3.I, '--', 'LineWidth',1.2, 'Color',green);
plot(R_mscc4.t, R_mscc4.I, '--', 'LineWidth',1.2, 'Color',red);
plot(R_mscc5.t, R_mscc5.I, '--', 'LineWidth',1.2, 'Color',orange);
plot(R_mscc6.t, R_mscc6.I, '--', 'LineWidth',1.2, 'Color',gray);
ylabel('I_{cell} (A)');

xlabel('t (s)');
legend({'E CCCV','E MSCC2','E MSCC3','E MSCC4','E MSCC5','E MSCC6', ...
        'I CCCV','I MSCC2','I MSCC3','I MSCC4','I MSCC5','I MSCC6'}, ...
        'Location','bestoutside');

% 축 색을 모두 검정으로
ax = gca;
ax.XColor      = 'k';
ax.YAxis(1).Color = 'k';
ax.YAxis(2).Color = 'k';

export_png(f1, fullfile(fig_out_dir, 'timeseries_voltage_current.png'));

%% 5.2) Figure 2 — (liion.Ect) vs time
f2 = figure(4102); clf; set(gcf,'Color','w'); hold on; grid on;
plot(R_cccv.t,  R_cccv.vdiff,  'LineWidth',1.6, 'Color',blue);
plot(R_mscc2.t, R_mscc2.vdiff, 'LineWidth',1.6, 'Color',purple);
plot(R_mscc3.t, R_mscc3.vdiff, 'LineWidth',1.6, 'Color',green);
plot(R_mscc4.t, R_mscc4.vdiff, 'LineWidth',1.6, 'Color',red);
plot(R_mscc5.t, R_mscc5.vdiff, 'LineWidth',1.6, 'Color',orange);
plot(R_mscc6.t, R_mscc6.vdiff, 'LineWidth',1.6, 'Color',gray);
xlabel('t (s)');
ylabel('Anode potential (V)');
title('Anode potential vs time (Optimal C)');
legend({'CCCV','MSCC2','MSCC3','MSCC4','MSCC5','MSCC6'}, 'Location','best');

ax = gca;
ax.XColor = 'k';
ax.YColor = 'k';

export_png(f2, fullfile(fig_out_dir, 'timeseries_anode_potential.png'));

%% 5.3) Figure 3 — T_{avg}, T_{max} vs time [°C]
f3 = figure(4103); clf; set(gcf,'Color','w'); hold on; grid on;

% 각 프로토콜 별 K -> °C 변환
TavgC_cccv  = R_cccv.Tavg  - 273.15;
TavgC_mscc2 = R_mscc2.Tavg - 273.15;
TavgC_mscc3 = R_mscc3.Tavg - 273.15;
TavgC_mscc4 = R_mscc4.Tavg - 273.15;
TavgC_mscc5 = R_mscc5.Tavg - 273.15;
TavgC_mscc6 = R_mscc6.Tavg - 273.15;

TmaxC_cccv  = R_cccv.Tmax  - 273.15;
TmaxC_mscc2 = R_mscc2.Tmax - 273.15;
TmaxC_mscc3 = R_mscc3.Tmax - 273.15;
TmaxC_mscc4 = R_mscc4.Tmax - 273.15;
TmaxC_mscc5 = R_mscc5.Tmax - 273.15;
TmaxC_mscc6 = R_mscc6.Tmax - 273.15;

% T_avg (°C)
plot(R_cccv.t,  TavgC_cccv,  '-',  'LineWidth',1.6, 'Color',blue);
plot(R_mscc2.t, TavgC_mscc2, '-',  'LineWidth',1.6, 'Color',purple);
plot(R_mscc3.t, TavgC_mscc3, '-',  'LineWidth',1.6, 'Color',green);
plot(R_mscc4.t, TavgC_mscc4, '-',  'LineWidth',1.6, 'Color',red);
plot(R_mscc5.t, TavgC_mscc5, '-',  'LineWidth',1.6, 'Color',orange);
plot(R_mscc6.t, TavgC_mscc6, '-',  'LineWidth',1.6, 'Color',gray);

% T_max (°C)
plot(R_cccv.t,  TmaxC_cccv,  '--', 'LineWidth',1.4, 'Color',blue);
plot(R_mscc2.t, TmaxC_mscc2, '--', 'LineWidth',1.4, 'Color',purple);
plot(R_mscc3.t, TmaxC_mscc3, '--', 'LineWidth',1.4, 'Color',green);
plot(R_mscc4.t, TmaxC_mscc4, '--', 'LineWidth',1.4, 'Color',red);
plot(R_mscc5.t, TmaxC_mscc5, '--', 'LineWidth',1.4, 'Color',orange);
plot(R_mscc6.t, TmaxC_mscc6, '--', 'LineWidth',1.4, 'Color',gray);

xlabel('t (s)');
ylabel('Temperature (°C)');
title('Temperature vs time (Optimal C)');
legend({'T_{avg} CCCV','T_{avg} MSCC2','T_{avg} MSCC3','T_{avg} MSCC4','T_{avg} MSCC5','T_{avg} MSCC6', ...
        'T_{max} CCCV','T_{max} MSCC2','T_{max} MSCC3','T_{max} MSCC4','T_{max} MSCC5','T_{max} MSCC6'}, ...
        'Location','bestoutside');

ax = gca;
ax.XColor = 'k';
ax.YColor = 'k';

export_png(f3, fullfile(fig_out_dir, 'timeseries_temperature.png'));

%%  ) 각각 그리기 ----------------------------------------------------------

% 프로토콜 리스트 (이후 플롯용)
PROT = struct('name',{},'R',{},'color',{});
PROT(end+1) = struct('name','CCCV',  'R',R_cccv,  'color',blue);
PROT(end+1) = struct('name','MSCC2', 'R',R_mscc2, 'color',purple);
PROT(end+1) = struct('name','MSCC3', 'R',R_mscc3, 'color',green);
PROT(end+1) = struct('name','MSCC4', 'R',R_mscc4, 'color',red);
PROT(end+1) = struct('name','MSCC5', 'R',R_mscc5, 'color',orange);
PROT(end+1) = struct('name','MSCC6', 'R',R_mscc6, 'color',gray);

%% 5.4) Voltage & Current vs time — 프로토콜별 개별 플롯
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    fV = figure(4200+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    title(sprintf('Voltage & Current vs time (Optimal C, %s)', P.name));

    yyaxis left;
    plot(R.t, R.E, '-', 'LineWidth',1.5, 'Color',[0 0.6 0]);   % green
    ylabel('E_{cell} (V)');

    yyaxis right;
    plot(R.t, R.I, '--', 'LineWidth',1.2, 'Color',[0.5 0 0.5]); % purple
    ylabel('I_{cell} (A)');

    xlabel('t (s)');
    legend({'E_{cell}','I_{cell}'}, 'Location','best');

    % 축 색 검정
    ax = gca;
    ax.XColor        = 'k';
    ax.YAxis(1).Color = 'k';
    ax.YAxis(2).Color = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_voltage_current_%s.png', P.name));
    export_png(fV, out_png);
end

%% 5.5) Temperature vs time — 프로토콜별 개별 플롯 (T_{avg}, T_{max}) [°C]
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    % K -> °C 변환
    TavgC = R.Tavg - 273.15;
    TmaxC = R.Tmax - 273.15;

    fT = figure(4300+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    title(sprintf('Temperature vs time (Optimal C, %s)', P.name));

    % T_avg: 파란색 실선 (°C)
    plot(R.t, TavgC, '-',  'LineWidth',1.6, 'Color',blue);
    % T_max: 빨간색 점선 (°C)
    plot(R.t, TmaxC, '--', 'LineWidth',1.4, 'Color',red);

    xlabel('t (s)');
    ylabel('Temperature (°C)');
    legend({'T_{avg}','T_{max}'}, 'Location','best');

    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_temperature_%s.png', P.name));
    export_png(fT, out_png);
end

%% 5.6) Anode potential vs time — 프로토콜별 개별 플롯
for k = 1:numel(PROT)
    P = PROT(k);
    R = P.R;

    fA = figure(4400+k); clf;
    set(gcf,'Color','w');
    grid off; hold on;

    plot(R.t, R.vdiff, 'LineWidth',1.6, 'Color', P.color);

    xlabel('t (s)');
    ylabel('Anode potential (V)');
    title(sprintf('Anode potential vs time (Optimal C, %s)', P.name));
    legend({P.name}, 'Location','best');

    ax = gca;
    ax.XColor = 'k';
    ax.YColor = 'k';

    hold off;

    out_png = fullfile(fig_out_dir, ...
        sprintf('timeseries_anode_potential_%s.png', P.name));
    export_png(fA, out_png);
end

%% 5.7) Thermal load metrics — ∫ΔT dt, ∫Qh dt per protocol
%  - Thermal burden:  J_T = ∫ (Tavg(t) - T_init) dt     [K·s ≒ °C·s]
%  - Heat generation: J_Q = ∫ Qh(t) dt                  [J/m^3]  (Qh: W/m^3)

nP     = numel(PROT);
names  = {PROT.name};
colors = vertcat(PROT.color);

J_T = zeros(nP,1);   % ∫ΔT dt
J_Q = zeros(nP,1);   % ∫Qh dt

for k = 1:nP
    R = PROT(k).R;

    t    = R.t(:);
    Tavg = R.Tavg(:);
    Qh   = R.Qh(:);

    % 각 프로토콜 자기 초기온도를 기준으로 ΔT 계산
    T_init = Tavg(1);

    dT = Tavg - T_init;          % [K]
    J_T(k) = trapz(t, dT);       % [K·s] ≒ [°C·s]
    J_Q(k) = trapz(t, Qh);       % [J/m^3]  (Qh: W/m^3 → 시간적분)
end

% --- (1) ∫ΔT dt bar plot --------------------------------------------------
fDT = figure(4501); clf; set(gcf,'Color','w');
b1 = bar(J_T);
b1.FaceColor = 'flat';
for k = 1:nP
    b1.CData(k,:) = colors(k,:);
end
grid on;

xticks(1:nP);
xticklabels(names);
xlabel('Protocol');
ylabel('\int \DeltaT_{avg}(t)\, dt  (°C·s)');
title('Thermal burden: \int (T_{avg}(t) - T_{init}) dt (Optimal C)');
set(gca,'FontSize',11);

out_DT = fullfile(fig_out_dir, 'thermal_JT_integral_deltaTavg.png');
export_png(fDT, out_DT);
fprintf('Saved: %s\n', out_DT);

% --- (2) ∫Qh dt bar plot --------------------------------------------------
fQh = figure(4502); clf; set(gcf,'Color','w');
b2 = bar(J_Q);
b2.FaceColor = 'flat';
for k = 1:nP
    b2.CData(k,:) = colors(k,:);
end
grid on;

xticks(1:nP);
xticklabels(names);
xlabel('Protocol');
ylabel('\int Q_h(t)\, dt  (J/m^3)');
title('Total heat generation: \int Q_h(t) dt (Optimal C)');
set(gca,'FontSize',11);

out_Qh = fullfile(fig_out_dir, 'thermal_JQ_integral_Qh.png');
export_png(fQh, out_Qh);
fprintf('Saved: %s\n', out_Qh);


%% ======================= Local helper functions ==========================
function fpath = pick_one_file(folder, pattern)
    L = dir(fullfile(folder, pattern));
    assert(~isempty(L), '파일이 없습니다: %s', fullfile(folder, pattern));
    [~,ix] = max([L.datenum]);           % 가장 최신 파일
    fpath = fullfile(L(ix).folder, L(ix).name);
end

function export_png(fig_handle, outpath)
    try
        set(fig_handle, 'Color','w');
        axs = findall(fig_handle, 'Type', 'axes');
        for ax = axs'
            try, axtoolbar(ax,'Visible','off'); end %#ok<TRYNC>
        end
        exportgraphics(fig_handle, outpath, 'Resolution', 220);
    catch ME
        warning('PNG 저장 실패 (%s): %s', outpath, ME.message);
    end
end

function mask_nd = isNondominatedND(F)
% F: [N x M], 각 열은 "최소화" 대상.
% 반환: 비지배(true)/지배(false)
    N = size(F,1);
    mask_nd = true(N,1);
    for i = 1:N
        if ~mask_nd(i), continue; end
        for j = 1:N
            if i==j, continue; end
            if all(F(j,:) <= F(i,:)) && any(F(j,:) < F(i,:))
                mask_nd(i) = false;
                break;
            end
        end
    end
end

function R = run_and_eval(protocol, model, Cvals, t_cycling)
    % run_and_eval
    %   - protocol : 'CCCV', 'MSCC2', ..., 'MSCC6'
    %   - Cvals    : 해당 프로토콜의 최적 C-rate 벡터
    %   - t_cycling: run_summary 에서 읽어온 최적 충전시간 [s]
    %
    % 여기서 dt_out 은 COMSOL Output times 의 두 번째 인자에 해당 (예: range(0,10,t_cycling))
    dt_out = 5;   % [s]  <--  원래 300이던 걸 10초 간격으로 저장하고 싶을 때

    % ===== (1) 파라미터 세팅 & 스터디/데이터셋 선택 =====
    switch protocol
        case 'CCCV'
            model.param.set('C_rate', num2str(Cvals(1)));
            studyTag = 'std1'; dset = 'dset1';

        case 'MSCC2'   % [C12 C3456]
            C12    = Cvals(1);
            C3456  = Cvals(2);
            model.param.set('first_MSCC_Crate',  num2str(C12));
            model.param.set('second_MSCC_Crate', num2str(C12));
            model.param.set('third_MSCC_Crate',  num2str(C3456));
            model.param.set('fourth_MSCC_Crate', num2str(C3456));
            model.param.set('fifth_MSCC_Crate',  num2str(C3456));
            model.param.set('sixth_MSCC_Crate',  num2str(C3456));
            studyTag = 'std2'; dset = 'dset3';

        case 'MSCC3'   % [C12 C34 C56]
            C12 = Cvals(1); C34 = Cvals(2); C56 = Cvals(3);
            model.param.set('first_MSCC_Crate',  num2str(C12));
            model.param.set('second_MSCC_Crate', num2str(C12));
            model.param.set('third_MSCC_Crate',  num2str(C34));
            model.param.set('fourth_MSCC_Crate', num2str(C34));
            model.param.set('fifth_MSCC_Crate',  num2str(C56));
            model.param.set('sixth_MSCC_Crate',  num2str(C56));
            studyTag = 'std2'; dset = 'dset3';

        case 'MSCC4'   % [C1 C2 C34 C56]
            C1 = Cvals(1); C2 = Cvals(2); C34 = Cvals(3); C56 = Cvals(4);
            model.param.set('first_MSCC_Crate',  num2str(C1));
            model.param.set('second_MSCC_Crate', num2str(C2));
            model.param.set('third_MSCC_Crate',  num2str(C34));
            model.param.set('fourth_MSCC_Crate', num2str(C34));
            model.param.set('fifth_MSCC_Crate',  num2str(C56));
            model.param.set('sixth_MSCC_Crate',  num2str(C56));
            studyTag = 'std2'; dset = 'dset3';

        case 'MSCC5'   % [C1 C2 C3 C4 C56]
            C1 = Cvals(1); C2 = Cvals(2); C3 = Cvals(3); C4 = Cvals(4); C56 = Cvals(5);
            model.param.set('first_MSCC_Crate',  num2str(C1));
            model.param.set('second_MSCC_Crate', num2str(C2));
            model.param.set('third_MSCC_Crate',  num2str(C3));
            model.param.set('fourth_MSCC_Crate', num2str(C4));
            model.param.set('fifth_MSCC_Crate',  num2str(C56));
            model.param.set('sixth_MSCC_Crate',  num2str(C56));
            studyTag = 'std2'; dset = 'dset3';

        case 'MSCC6'   % [C1 C2 C3 C4 C5 C6]
            C1=Cvals(1); C2=Cvals(2); C3=Cvals(3); C4=Cvals(4); C5=Cvals(5); C6=Cvals(6);
            model.param.set('first_MSCC_Crate',  num2str(C1));
            model.param.set('second_MSCC_Crate', num2str(C2));
            model.param.set('third_MSCC_Crate',  num2str(C3));
            model.param.set('fourth_MSCC_Crate', num2str(C4));
            model.param.set('fifth_MSCC_Crate',  num2str(C5));
            model.param.set('sixth_MSCC_Crate',  num2str(C6));
            studyTag = 'std2'; dset = 'dset3';

        otherwise
            error('Unknown protocol');
    end

    % ---- (1-1) 최적 시간 t_cycling 파라미터 세팅 ----
    % COMSOL 모델 안에 't_cycling' 파라미터가 존재해야 함
    model.param.set('t_cycling', num2str(t_cycling));

    % ---- (1-2) Output times = range(0, dt_out, t_cycling) 로 세팅 ----
    tlist_str = sprintf('range(0,%g,t_cycling)', dt_out);
    set_tlist_safe(model, studyTag, tlist_str);

    % ===== (2) 단일 실행 =====
    model.study(studyTag).run();

    % ===== (3) 데이터 취득 =====
    expr = {'t','E_cell','liion.cdc1.Icell','liion.Ect','T_avg','T_max', ...
            'liion.cdc1.CC_CH','liion.cdc1.CV_CH', ...
            'liion.Qh'};   % ★ liion.Qh 추가
    D = mpheval(model, expr, 'dataset',dset,'edim','point','selection',2,'solnum','all');

    t  = D.d1;  E  = D.d2;  I  = D.d3;  v = D.d4;
    Ta = toCol(D,5); Tm = toCol(D,6);
    cc = D.d7;  cv = D.d8;
    Qh = toCol(D,9);    % ★ Qh 시계열

    idx = (cc==1) | (cv==1); 
    if ~any(idx), idx = true(size(t)); end

    R = struct('t',t(idx),'E',E(idx),'I',I(idx), ...
               'vdiff',v(idx),'Tavg',Ta(idx),'Tmax',Tm(idx), ...
               'Qh',Qh(idx));   % ★ R에 Qh 추가
end


function col = toCol(D, k)
    try
        col = D.(['d' num2str(k)]);
    catch
        col = nan(size(D.d1));
    end
end

function set_tlist_safe(model, studyTag, tlist_str)
    tried = false;
    for cand = {'time','time1','time2','step1','step2'}
        try
            model.study(studyTag).feature(char(cand)).set('tlist', tlist_str);
            tried = true; 
            break;
        catch
        end
    end
    for solCand = {'sol1','sol2'}
        for featCand = {'t1','t2','time','time1'}
            try
                model.sol(char(solCand)).feature(char(featCand)).set('tlist', tlist_str);
            catch
            end
        end
    end
    if ~tried
        warning('tlist 설정 실패: study=%s (기본 설정으로 계속 진행)', studyTag);
    end
end

